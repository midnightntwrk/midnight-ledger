// This file is part of midnight-ledger.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! Derive macros for `midnight-storage`.
extern crate proc_macro;
use proc_macro2::TokenStream;
use quote::{ToTokens, format_ident, quote};
use syn::{
    Attribute, Data, DeriveInput, Expr, Field, Fields, GenericParam, Generics, Ident, Meta,
    MetaNameValue, Token, parse::Parser, parse_macro_input, parse_quote, punctuated::Punctuated,
};

fn add_trait_bounds(mut generics: Generics, phantom: &[Ident], db: &Ident) -> Generics {
    for param in &mut generics.params {
        if let GenericParam::Type(ref mut type_param) = *param {
            if !phantom.contains(&type_param.ident) {
                type_param.bounds.push(parse_quote!(Storable<#db>));
            }
        }
    }
    generics
}

fn tagged_add_trait_bounds(mut generics: Generics, phantom: &[Ident]) -> Generics {
    for param in &mut generics.params {
        if let GenericParam::Type(ref mut type_param) = *param {
            if !phantom.contains(&type_param.ident) {
                type_param.bounds.push(parse_quote!(Tagged));
            }
        }
    }
    generics
}

/// #[derive(Storable)] macro.
///
/// Any children of type Sp<_> annotated with #[storable(child)] will be treated as child-nodes
/// in the Storable implementation, as such the
/// generated `Storable` impl will return the `ArenaKey` of any such annotated fields
/// as part of `Storable::children(..)`, and they will consiquently be ommited from
/// the binary representation as generated by `Storable::to_binary_repr`, and in
/// `Storable::from_binary_repr` they will be populated via `loader.get_next(..)`.
///
/// Any children not annotated with #[storable(child)] will be in-lined, i.e. any of their
/// children will be included in parent.children(), and their binary representation will be
/// included in parent.to_binary_repr.
///
/// Optionally, if parameterised over D: DB, (i.e. children of type Sp<_, D>) the
/// struct can be annotated with #[storable(db = D)]. This results in the `Storable`
/// impl being implemented for `Storable<D>`. If ommited `Storable` is implemented for
/// `Storable<DefaultDB>`.
///
/// This macro will also automatically implement `Serializable`,
/// `Deserializable`, and if the `#[tag = "..."]` attribute is present,
/// `Tagged`. It also respects the `#[phantom(...)]` attribute to mark type
/// parameters not to include in generic constraints and the tag (with the DB
/// parameter automatically being included).
///
/// When the attribute `#[storable(base)]` is present, this macros behaviour changes to treat this
/// as a leaf in the storage tree instead. In this case, `Serializable` must be implemented
/// separately, and the `Storable` implementation uses this as its binary representation, with no
/// children.
///
/// When an attribute `#[storable(invariant = some_function)]` is set, `some_function` is used as the
/// `Storable::check_invariant` implementation.
#[proc_macro_derive(Storable, attributes(storable, tag, phantom))]
pub fn derive_storable(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    if let Some(base_output) = is_base(&input) {
        return proc_macro::TokenStream::from(base_output);
    };

    let name = input.ident.clone();

    let mut phantom_generics = input
        .attrs
        .iter()
        .find_map(|attr| match &attr.meta {
            Meta::List(l) if l.path.is_ident("phantom") => {
                let parser = Punctuated::<Ident, Token![,]>::parse_separated_nonempty;
                parser
                    .parse2(l.tokens.clone())
                    .ok()
                    .map(|punct| punct.iter().cloned().collect::<Vec<_>>())
            }
            _ => None,
        })
        .unwrap_or(vec![]);
    let (db, invariant) = parse_macro_args(&input);
    let db = if let Some(db) = db {
        phantom_generics.push(db.clone());
        db
    } else {
        format_ident!("DefaultDB")
    };
    let tag = input.attrs.iter().find_map(|attr| match &attr.meta {
        Meta::NameValue(nv) if nv.path.is_ident("tag") => Some(&nv.value),
        _ => None,
    });

    let enriched_generics = add_trait_bounds(input.generics.clone(), &phantom_generics, &db);
    let (impl_generics, ty_generics, where_clause) = enriched_generics.split_for_impl();

    let children_impl = derive_children(&input.data, &db);
    let to_binary_repr_impl = derive_to_binary_repr(&input.data, &db);
    let from_binary_repr_impl = derive_from_binary_repr(&input.data, &db);

    let invariant_impl = invariant.map(|expr| {
        quote! {
            fn check_invariant(&self) -> Result<(), std::io::Error> {
                #expr(self)
            }
        }
    });

    let mut expanded = quote! {
        #[allow(unused)]
        impl #impl_generics Storable<#db> for #name #ty_generics #where_clause {
            fn children(&self) -> std::vec::Vec<ArenaKey<<#db as DB>::Hasher>> {
                #children_impl
            }

            fn to_binary_repr<W: std::io::Write>(&self, writer: &mut W) -> Result<(), std::io::Error> {
                #to_binary_repr_impl
            }

            fn from_binary_repr<R: std::io::Read>(reader: &mut R, child_hashes: &mut impl Iterator<Item = ArenaKey<<#db as DB>::Hasher>>, loader: &impl Loader<#db>) -> Result<Self, std::io::Error> {
                #from_binary_repr_impl
            }

            #invariant_impl
        }

        impl #impl_generics serialize::Serializable for #name #ty_generics #where_clause {
            fn serialize(&self, __writer: &mut impl ::std::io::Write) -> ::std::io::Result<()> {
                <storage::arena::Sp<#name #ty_generics, #db> as serialize::Serializable>::serialize(&storage::arena::Sp::new(self.clone()), __writer)
            }
            fn serialized_size(&self) -> usize {
                <storage::arena::Sp<#name #ty_generics, #db> as serialize::Serializable>::serialized_size(&storage::arena::Sp::new(self.clone()))
            }
        }

        impl #impl_generics serialize::Deserializable for #name #ty_generics #where_clause {
            fn deserialize(__reader: &mut impl ::std::io::Read, recursion_depth: u32) -> ::std::io::Result<Self> {
                let sp = <storage::arena::Sp<#name #ty_generics, #db> as serialize::Deserializable>::deserialize(__reader, recursion_depth)?;
                Ok((&*sp).clone())
            }
        }
    };

    if let Some(tag) = tag {
        let tag_generics = tagged_add_trait_bounds(input.generics, &phantom_generics);
        let (tag_impl_generics, tag_ty_generics, tag_where_clause) = tag_generics.split_for_impl();

        let generics = tag_generics
            .params
            .iter()
            .filter_map(|param| match param {
                GenericParam::Type(ty) if !phantom_generics.contains(&ty.ident) => Some(&ty.ident),
                _ => None,
            })
            .collect::<Vec<_>>();

        let tag_expand = if generics.is_empty() {
            quote! { ::std::borrow::Cow::Borrowed(#tag) }
        } else {
            let mut fstring = String::new();
            fstring.push_str("{}(");
            for i in 0..generics.len() {
                if i > 0 {
                    fstring.push_str(",");
                }
                fstring.push_str("{}");
            }
            fstring.push_str(")");
            quote! { ::std::borrow::Cow::Owned(::std::format!(#fstring, #tag, #( <#generics as Tagged>::tag() ),*)) }
        };
        let tag_factor_expand = tag_factors(&input.data);

        expanded.extend(quote! {
            impl #tag_impl_generics Tagged for #name #tag_ty_generics #tag_where_clause {
                fn tag() -> ::std::borrow::Cow<'static, ::core::primitive::str> {
                    #tag_expand
                }
                fn tag_unique_factor() -> String {
                    #tag_factor_expand
                }
            }
        });
    }

    proc_macro::TokenStream::from(expanded)
}

fn tag_factors_fields_fmt_str(fields: &Fields) -> String {
    let mut res = String::new();
    res.push('(');
    for (i, field) in fields.iter().enumerate() {
        if i != 0 {
            res.push(',');
        }
        let field_ty = child_field(field);
        match field_ty {
            FieldTypes::Child => res.push_str("#{}"),
            FieldTypes::Inline => res.push_str("{}"),
        }
    }
    res.push(')');
    res
}

fn tag_factors_fields_fmt_args(fields: &Fields) -> impl Iterator<Item = TokenStream> {
    fields.iter().map(|field| &field.ty).map(|ty| {
        quote! {
            <#ty>::tag()
        }
    })
}

fn tag_factors(data: &Data) -> TokenStream {
    let fmt_str = match data {
        Data::Struct(data) => format!("({})", tag_factors_fields_fmt_str(&data.fields)),
        Data::Enum(data) => {
            let mut res = String::new();
            res.push('[');
            for (i, variant) in data.variants.iter().enumerate() {
                if i != 0 {
                    res.push(',');
                }
                res.push_str(&tag_factors_fields_fmt_str(&variant.fields));
            }
            res.push(']');
            res
        }
        Data::Union(_) => unimplemented!(),
    };
    let fmt_args: Box<dyn Iterator<Item = TokenStream>> = match data {
        Data::Struct(data) => Box::new(tag_factors_fields_fmt_args(&data.fields)),
        Data::Enum(data) => Box::new(
            data.variants
                .iter()
                .flat_map(|var| tag_factors_fields_fmt_args(&var.fields)),
        ),
        Data::Union(_) => unimplemented!(),
    };
    quote! {
        format!(#fmt_str, #(#fmt_args),*)
    }
}

fn is_base(input: &DeriveInput) -> Option<TokenStream> {
    let attrs: std::vec::Vec<&Attribute> = input
        .attrs
        .iter()
        .filter(|attr| (**attr).path().is_ident("storable"))
        .collect();

    let is_base = attrs.iter().any(|attr| match &attr.meta {
        Meta::List(list) => list.tokens.clone().into_iter().next().unwrap().to_string() == "base",
        _ => false,
    });

    is_base.then(|| {
        let name = &input.ident;
        let (impl_generics, ty_generics, where_clause) = input.generics.split_for_impl();
        let mut impl_tokens = impl_generics.to_token_stream();
        if impl_tokens.is_empty() {
            impl_tokens = quote! { <_D: DB> };
        } else {
            impl_tokens = quote! { <_D: DB, }.into_iter().chain(impl_tokens.into_iter().skip(1)).collect();
        };
        quote! {
            impl #impl_tokens Storable<_D> for #name #ty_generics #where_clause {
                fn children(&self) -> std::vec::Vec<ArenaKey<<_D as DB>::Hasher>> {
                    vec![]
                }

                fn to_binary_repr<W: std::io::Write>(&self, writer: &mut W) -> Result<(), std::io::Error> {
                    <Self as Serializable>::serialize(self, writer)
                }

                fn from_binary_repr<R: std::io::Read>(reader: &mut R, _child_hashes: &mut impl Iterator<Item = ArenaKey<<_D as DB>::Hasher>>, loader: &impl Loader<_D>) -> Result<Self, std::io::Error> {
                    loader.do_check(<Self as Deserializable>::deserialize(reader, loader.get_recursion_depth())?)
                }
            }
        }
    })
}

fn parse_macro_args(input: &DeriveInput) -> (Option<Ident>, Option<Expr>) {
    use std::collections::HashMap;
    // Find #[storable(...)] attrs
    let attrs: Vec<Punctuated<MetaNameValue, Token![,]>> = input
        .attrs
        .iter()
        .filter(|attr| (**attr).path().is_ident("storable"))
        .filter_map(|attr| match &attr.meta {
            Meta::List(list) => list
                .parse_args_with(Punctuated::parse_separated_nonempty)
                .ok(),
            _ => None,
        })
        .collect::<Vec<_>>();

    let kvs = attrs
        .iter()
        .flat_map(|attr| {
            attr.iter()
                .filter_map(|meta| Some((format!("{}", meta.path.get_ident()?), &meta.value)))
        })
        .collect::<HashMap<_, _>>();

    let db = kvs.get("db").and_then(|expr| match expr {
        Expr::Path(p) => p.path.get_ident().cloned(),
        _ => None,
    });
    (db, kvs.get("invariant").cloned().cloned())
}

#[derive(PartialEq)]
enum FieldTypes {
    Child,
    Inline,
}

fn child_field(field: &Field) -> FieldTypes {
    let expt_child = parse_quote! { #[storable(child)] };

    for attr in field.attrs.iter() {
        if attr == &expt_child {
            return FieldTypes::Child;
        }
    }

    FieldTypes::Inline
}

fn derive_children_fields(fields: &Fields, db: &Ident) -> TokenStream {
    match fields {
        Fields::Named(f) => {
            let field_names = f
                .named
                .iter()
                .map(|f| f.ident.as_ref().expect("named field"));
            let field_children = f.named.iter().map(|f| {
                let ident = f.ident.as_ref().expect("named field");
                match child_field(&f) {
                    FieldTypes::Child => quote! { child_hashes.push(Sp::hash(#ident).into()); },
                    FieldTypes::Inline => {
                        quote! { child_hashes.append(&mut Storable::<#db>::children(#ident)); }
                    }
                }
            });
            quote! {
                { #(#field_names),* } => {
                    #(#field_children)*
                }
            }
        }
        Fields::Unnamed(f) => {
            let field_names = f
                .unnamed
                .iter()
                .enumerate()
                .map(|(i, _)| format_ident!("_{i}"));
            let field_children = f.unnamed.iter().enumerate().map(|(i, f)| {
                let ident = format_ident!("_{i}");
                match child_field(&f) {
                    FieldTypes::Child => quote! { child_hashes.push(Sp::hash(#ident).into()); },
                    FieldTypes::Inline => {
                        quote! { child_hashes.append(&mut Storable::<#db>::children(#ident)); }
                    }
                }
            });
            quote! {
                ( #(#field_names),* ) => {
                    #(#field_children)*
                }
            }
        }
        Fields::Unit => quote! { => {} },
    }
}

fn derive_children(data: &Data, db: &Ident) -> TokenStream {
    match data {
        Data::Struct(data) => {
            let handle = derive_children_fields(&data.fields, db);
            quote! {
                let mut child_hashes = std::vec::Vec::new();
                match self {
                    Self #handle
                }
                child_hashes
            }
        }
        Data::Enum(data) => {
            let var_names = data.variants.iter().map(|var| &var.ident);
            let var_handle = data
                .variants
                .iter()
                .map(|var| derive_children_fields(&var.fields, db));
            quote! {
                let mut child_hashes = std::vec::Vec::new();
                match self {
                    #(Self::#var_names #var_handle)*
                }
                child_hashes
            }
        }
        _ => {
            panic!("Cannot derive Storable for unions")
        }
    }
}

fn derive_to_binary_repr_fields(fields: &Fields, db: &Ident, extra: TokenStream) -> TokenStream {
    match fields {
        Fields::Named(f) => {
            let field_names = f
                .named
                .iter()
                .map(|field| field.ident.as_ref().expect("named field"));
            let field_writes = f.named.iter().filter_map(|field| {
                let name = field.ident.as_ref().expect("named field");
                match child_field(&field) {
                    FieldTypes::Child => None,
                    FieldTypes::Inline => {
                        Some(quote! { Storable::<#db>::to_binary_repr(#name, writer)?; })
                    }
                }
            });
            quote! {
                { #(#field_names, )* } => {
                    #extra
                    #(#field_writes)*
                }
            }
        }
        Fields::Unnamed(f) => {
            let field_names = f
                .unnamed
                .iter()
                .enumerate()
                .map(|(i, _)| format_ident!("_{i}"))
                .collect::<Vec<_>>();
            let field_writes = f
                .unnamed
                .iter()
                .zip(field_names.iter())
                .filter_map(|(field, name)| match child_field(&field) {
                    FieldTypes::Child => None,
                    FieldTypes::Inline => {
                        Some(quote! { Storable::<#db>::to_binary_repr(#name, writer)?; })
                    }
                })
                .collect::<Vec<_>>();
            quote! {
                ( #(#field_names),* ) => {
                    #extra
                    #(#field_writes)*
                }
            }
        }
        Fields::Unit => quote! { => { #extra } },
    }
}

fn derive_to_binary_repr(data: &Data, db: &Ident) -> TokenStream {
    match data {
        Data::Struct(data) => {
            let field_write = derive_to_binary_repr_fields(&data.fields, db, quote! {});
            quote! {
                match self {
                    Self #field_write
                }
                Ok(())
            }
        }
        Data::Enum(data) => {
            let variant = data.variants.iter().map(|var| &var.ident);
            let variant_write = data
                .variants
                .iter()
                .enumerate()
                .map(|(i, var)| (i as u8, var))
                .map(|(i, var)| {
                    derive_to_binary_repr_fields(
                        &var.fields,
                        db,
                        quote! {writer.write_all(&[#i])?;},
                    )
                });
            quote! {
                match self {
                    #(Self::#variant #variant_write)*
                }
                Ok(())
            }
        }
        _ => {
            panic!("Cannot derive Storable for unions")
        }
    }
}

fn derive_from_binary_repr_field(fields: &Fields) -> TokenStream {
    match fields {
        Fields::Named(f) => {
            let deserialize_children = f.clone().named.into_iter().map(|field| {
                let ident = field.ident.clone().expect("named field");
                match child_field(&field) {
                    FieldTypes::Child => quote! {#ident: loader.get_next(child_hashes)?},
                    FieldTypes::Inline => {
                        quote! {#ident: Storable::from_binary_repr(reader, child_hashes, loader)?}
                    }
                }
            });
            quote! {
                {
                    #(#deserialize_children,)*
                }
            }
        }
        Fields::Unnamed(f) => {
            let deserialize_children =
                f.clone()
                    .unnamed
                    .into_iter()
                    .map(|field| match child_field(&field) {
                        FieldTypes::Child => quote! {loader.get_next(child_hashes)?},
                        FieldTypes::Inline => {
                            quote! {Storable::from_binary_repr(reader, child_hashes, loader)?}
                        }
                    });
            quote! {
                (
                    #(#deserialize_children,)*
                )
            }
        }
        Fields::Unit => quote! {},
    }
}

fn derive_from_binary_repr(data: &Data, _db: &Ident) -> TokenStream {
    match data {
        Data::Struct(data) => {
            let field_code = derive_from_binary_repr_field(&data.fields);
            quote! {
                loader.do_check(Self #field_code)
            }
        }
        Data::Enum(data) => {
            let match_arms = data
                .variants
                .iter()
                .enumerate()
                .map(|(n, variant)| {
                    let n = n as u8;
                    let var_id = &variant.ident;
                    let field_code = derive_from_binary_repr_field(&variant.fields);
                    quote! {
                        #n => Self::#var_id #field_code
                    }
                })
                .collect::<Vec<_>>();
            quote! {
                let mut __variant = [0u8];
                reader.read_exact(&mut __variant[..])?;
                loader.do_check(match __variant[0] {
                    #(#match_arms,)*
                    _ => return Err(::std::io::Error::new(::std::io::ErrorKind::InvalidData, "invalid variant")),
                })
            }
        }
        _ => {
            panic!("Cannot derive Storable for unions")
        }
    }
}
