// This file is part of midnight-ledger.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import CompactStandardLibrary;

struct ZswapCoinSecretKey {
  bytes: Bytes<32>;
}

struct CoinPreimage {
  info: ShieldedCoinInfo,
  dataType: Boolean,
  data: Bytes<32>,
  sep: Bytes<6>,
}

ledger merkleTree: HistoricMerkleTree<32, Bytes<32>>;
ledger nullifiers: Set<Bytes<32>>;
ledger valueCom: CurvePoint;
ledger contractAddr: ContractAddress;
ledger publicKey: ZswapCoinPublicKey;
ledger segment: Uint<16>;

export circuit spend(
  sk: Either<ZswapCoinSecretKey, ContractAddress>,
  path: MerkleTreePath<32, Bytes<32>>,
  coin: ShieldedCoinInfo,
  rc: Field
): [] {
  merkleTree.checkRoot(disclose(merkleTreePathRootNoLeafHash<32>(path)));
  const pk = derivePublicKey(sk.left);
  const coinCom = persistentHash<CoinPreimage>(
    CoinPreimage {
      info: coin,
      dataType: sk.is_left,
      data: sk.is_left? pk.bytes : sk.right.bytes,
      sep: "mdn:cc"
    });
  assert(coinCom == path.leaf, "Path must be to coin commitment");

  const nul = persistentHash<CoinPreimage>(
      CoinPreimage {
        info: coin,
        dataType: sk.is_left,
        data: sk.is_left ? sk.left.bytes : sk.right.bytes,
        sep: "mdn:cn"
      });
  nullifiers.insert(disclose(nul));
  if(!disclose(sk.is_left)) {
    contractAddr = disclose(sk.right);
  }
  const colorBase = hashToCurve<[Bytes<32>, Uint<16>]>([coin.color, segment]);
  const pedersenBlinding = ecMulGenerator(rc);
  const pedersenCommit = ecMul(colorBase, coin.value);
  valueCom = disclose(ecAdd(pedersenBlinding, pedersenCommit));
}

struct PublicKeyPreimage {
  secretKey: ZswapCoinSecretKey,
  sep: Bytes<6>,
}

circuit derivePublicKey(secretKey: ZswapCoinSecretKey): ZswapCoinPublicKey {
  return ZswapCoinPublicKey {
    bytes: persistentHash<PublicKeyPreimage>(PublicKeyPreimage {
      secretKey: secretKey,
      sep: "mdn:pk"
    })
  };
}

export circuit output(
  pk: Either<ZswapCoinPublicKey, ContractAddress>,
  coin: ShieldedCoinInfo,
  rc: Field
): [] {
  const coinCom = persistentHash<CoinPreimage>(
    CoinPreimage {
      info: coin,
      dataType: pk.is_left,
      data: pk.is_left ? pk.left.bytes : pk.right.bytes,
      sep: "mdn:cc"
    });
  merkleTree.insertHash(disclose(coinCom));
  if(!disclose(pk.is_left)) {
    contractAddr = disclose(pk.right);
  }
  const colorBase = hashToCurve<[Bytes<32>, Uint<16>]>([coin.color, segment]);
  const pedersenBlinding = ecMulGenerator(rc);
  const pedersenCommit = ecMul(colorBase, coin.value);
  valueCom = disclose(ecAdd(pedersenBlinding, pedersenCommit));
}

export circuit sign(secretKey: ZswapCoinSecretKey): [] {
  publicKey = disclose(derivePublicKey(secretKey));
}
